# Code to convert Dcf generated by the Polymender into a nrrd file 
import sys
import struct
import numpy




offset=[[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]

data=[]




# main start
def main():
    pointerLocInDataBytes=[10]# starts from 10 to accomodate 'multisign'
    
    fileName=sys.argv[1]
    depth=int(sys.argv[2])
    input=[fileName, depth]
    
    dataBytes=[]
    #Read the data from the .dcf file into dataBytes
    readBytes(fileName, dataBytes)
    #read the lenght of the grid in each direction 
    XLength = convert("i", pointerLocInDataBytes, dataBytes, 4)
    YLength = convert("i", pointerLocInDataBytes, dataBytes, 4)
    ZLength = convert("i", pointerLocInDataBytes, dataBytes, 4)
    #DEBUG
    print "x[", XLength, "]y[", YLength, "]z[", ZLength, "]"
    global data
    data=numpy.ones((XLength, YLength, ZLength))
    
    #set the current Level
    currLevel=[depth]
    #set the current Location to 0
    currLoc=[0,0,0]
    #Process the nodes
    ProcessNode(pointerLocInDataBytes, dataBytes, input, currLevel , currLoc, )
    f = open('data.txt', 'w')
    print >>f, data




#Process the nodes
def ProcessNode(pointerLocInDataBytes, dataBytes, input, currLevel, currLoc):
    
    #Compute Node Type (0,1,2)
    NodeType = convert("i", pointerLocInDataBytes, dataBytes, 4)
    
    if NodeType == 0 :
        print "Node Type 0 , level ",currLevel
        #decrease the level
        currLevel[0]=currLevel[0]-1
        TempCurrLevel = currLevel
        TempCurrLoc = currLoc
        Length = pow(2,currLevel[0])
        for nodeNum in range(8):
            print "Node Number ", nodeNum
            #reset the currLevel, and Location
            currLevel = TempCurrLevel
            currLoc = TempCurrLoc
            
            
            #Compute the child locations
            childLoc = [TempCurrLoc[x] + offset[nodeNum][x]*Length for x in range(3)]
            print "Child Loc ",childLoc
            ProcessNode(pointerLocInDataBytes, dataBytes, input, TempCurrLevel, childLoc)
            
    if NodeType == 1 :
        isOutside = convert("h", pointerLocInDataBytes, dataBytes, 2)
        print "Node Type 1, empty node level ",currLevel, "is Outside ", isOutside
    
    if NodeType == 2 :
        Length = pow(2,currLevel[0])
        print "Node Type 2, leaf node reached level ",currLevel
        #print "base ",currLoc
        
        for nodeNum in range (8):
            nodeLoc  = [currLoc[x] + Length*offset[nodeNum][x] for x in range (3)]
            scalar = convert("h", pointerLocInDataBytes, dataBytes, 2)
            data[nodeLoc[0]][nodeLoc[1]][nodeLoc[2]] = scalar
        print " "
        for edgeNum in range(12):
            NumPointsOnEdge = convert("i", pointerLocInDataBytes, dataBytes, 4)
            for pointsInEdge in range(NumPointsOnEdge):
                edgeOffset = convert("f", pointerLocInDataBytes, dataBytes, 4)
                N0 = convert("f", pointerLocInDataBytes, dataBytes, 4)
                N1 = convert("f", pointerLocInDataBytes, dataBytes, 4)
                N2 = convert("f", pointerLocInDataBytes, dataBytes, 4)
                #print " ", edgeOffset, "[",N0," ",N1," ",N2,"]"
            

    


#Function to read the bytes in to the variable dataBytes
def readBytes(fileName, dataBytes):
    with open(fileName, "rb") as f:
        byte = f.read(1)
        while byte != "":
            dataBytes.append(byte)
            byte = f.read(1)
    

#Convert the bytes in dataBytes into data
def convert(Datatyp, pointerLocInDataBytes, dataBytes, num): 
    s = pointerLocInDataBytes[0]
    pointerLocInDataBytes[0] = pointerLocInDataBytes[0] + num
    return   struct.unpack("<"+Datatyp, ''.join(dataBytes[s:s+num]))[0]

# call the main function
if __name__ == "__main__":
    main()


# Code to convert Dcf generated by the Polymender into a nrrd file 
import sys
import struct
import numpy
from array import array



offset=[[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]

data=[]




# main start
def main():
    pointerLocInDataBytes=[10]# starts from 10 to accomodate 'multisign'
    
    fileName=sys.argv[1]
    depth=int(sys.argv[2])
    input=[fileName, depth]
    
    dataBytes=[]
    #Read the data from the .dcf file into dataBytes
    readBytes(fileName, dataBytes)
    #read the lenght of the grid in each direction 
    XLength = convert("i", pointerLocInDataBytes, dataBytes, 4)
    YLength = convert("i", pointerLocInDataBytes, dataBytes, 4)
    ZLength = convert("i", pointerLocInDataBytes, dataBytes, 4)
    #DEBUG
    print "x[", XLength, "]y[", YLength, "]z[", ZLength, "]"
    global data
    data=numpy.zeros((XLength+1, YLength+1, ZLength+1))
    for i in range (XLength+1):
        for j in range (YLength+1):
            for k in range (ZLength+1):
                data[i][j][k]= 1
    
    #set the current Level
    currLevel=[depth]
    #set the current Location to 0
    currLoc=[0,0,0]
    #Process the nodes
    ProcessNode(pointerLocInDataBytes, dataBytes, input, currLevel , currLoc, )
    
    
    #write to the nrrd file 
    
    f = open('data.nhdr', 'w')
    print >>f, "NRRD0001"
    print >>f, "content: data \ndimension: 3 \ntype: float"
    print >>f, "sizes: ", ZLength+1,YLength+1,XLength+1 
    print >>f, "spacings: 1 1 1" 
    scalarData=[]
    for i in range (XLength+1):
      for j in range (YLength+1):
        for k in range (ZLength+1):
          scalarData.append(data[i][j][k])
    print >>f, "".join(scalarData[:])
    f.close()
#Process the nodes
def ProcessNode(pointerLocInDataBytes, dataBytes, input, currLevel, currLoc):
    global data
    #Compute Node Type (0,1,2)
    NodeType = convert("i", pointerLocInDataBytes, dataBytes, 4)
    
    if NodeType == 0 :
        print "Node Type 0 , level ",currLevel
        #decrease the level
        currLevel[0]=currLevel[0]-1
        
        TempCurrLevel = currLevel
        TempCurrLoc = currLoc
        Length = pow(2,currLevel[0])
        for nodeNum in range(8):
            print " ------- "
            print "children Node Number ", nodeNum,
            #reset the currLevel, and Location
            TempCurrLevel = currLevel
            TempCurrLoc = currLoc 
            
            #Compute the child locations
            childLoc = [TempCurrLoc[x] + offset[nodeNum][x]*Length for x in range(3)]
            print "Child Loc  base ",childLoc
            ProcessNode(pointerLocInDataBytes, dataBytes, input, TempCurrLevel, childLoc)
            print " ------- "
        currLevel[0]=currLevel[0]+1
            
    if NodeType == 1 :
        isOutside = convert("h", pointerLocInDataBytes, dataBytes, 2)
        print "Node Type 1, empty node level ",currLevel, "is Outside ", isOutside
    #data[currLoc[0]][currLoc[1]][currLoc[2]] = isOutside
    
    if NodeType == 2 :
        Length = pow(2,currLevel[0])
        print "Node Type 2, leaf node reached level ",currLevel
        
        for nodeNum in range (8):
            nodeLoc  = [currLoc[x] + offset[nodeNum][x] for x in range (3)]
            scalar = convert("h", pointerLocInDataBytes, dataBytes, 2)
            data[nodeLoc[0]][nodeLoc[1]][nodeLoc[2]] = scalar
        
        for edgeNum in range(12):
            NumPointsOnEdge = convert("i", pointerLocInDataBytes, dataBytes, 4)
            for pointsInEdge in range(NumPointsOnEdge):
                edgeOffset = convert("f", pointerLocInDataBytes, dataBytes, 4)
                N0 = convert("f", pointerLocInDataBytes, dataBytes, 4)
                N1 = convert("f", pointerLocInDataBytes, dataBytes, 4)
                N2 = convert("f", pointerLocInDataBytes, dataBytes, 4)
                #print " ", edgeOffset, "[",N0," ",N1," ",N2,"]"
            

    


#Function to read the bytes in to the variable dataBytes
def readBytes(fileName, dataBytes):
    with open(fileName, "rb") as f:
        byte = f.read(1)
        while byte != "":
            dataBytes.append(byte)
            byte = f.read(1)
    

#Convert the bytes in dataBytes into data
def convert(Datatyp, pointerLocInDataBytes, dataBytes, num): 
    s = pointerLocInDataBytes[0]
    pointerLocInDataBytes[0] = pointerLocInDataBytes[0] + num
    return   struct.unpack("<"+Datatyp, ''.join(dataBytes[s:s+num]))[0]

# call the main function
if __name__ == "__main__":
    main()


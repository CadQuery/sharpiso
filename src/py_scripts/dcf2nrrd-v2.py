#!/usr/bin/python
#Code to generate the nrrd from the dcf generated by the polymender
#along with the normals and the intersection positions
'''
parameters
1. filename
'''
'''
xaxis size is the number of edges, the number of vertices is xaxis size + 1
'''
import numpy
import sys
import struct
class Params:
    fname = ""
    dataBytes=[]
    currLoc = 10
    

class gridType:
    xsize=0
    ysize=0
    zsize=0
    vertPerUnitL=1
    # number of leaf nodes 
    num_leaf=0
    #base loc 
    cuur_bas_loc=[0,0,0]
    #offsets
    offset=[[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
    #edgeoffset {0,4}, {1,5}, {2,6}, {3,7}, {0,2}, {1,3}, {4,6}, {5,7}, {0,1}, 
    # {2,3}, {4,5}, {6,7}.
    edgeOffset =[[0,4],[1,5],[2,6],[3,7],[0,2],[1,3],[4,6],[5,7],\
                 [0,1],[2,3],[4,5],[6,7]]
    #scalar data
    data=[]
    #pointgradient information 
    edgeIntersections=[]
    def setSize(self,_x,_y,_z):
        self.xsize=_x
        self.ysize=_y
        self.zsize=_z
        self.initScalarData()
    def initScalarData(self):
        if (self.xsize != self.ysize):
            print "axis sizes should be same"
            sys.exit()
        self.data=numpy.zeros((self.xsize+1,self.ysize+1,self.zsize+1))
        print "data set"
        #self.scalarData=[[None]*self.xsize for x in range(3)]
    def debugPrint(self):
        print  "************************************"
        print  "size", self.xsize, self.ysize,self.zsize
        print  "num_leaf", self.num_leaf
        print  "cuur_bas_loc", self.cuur_bas_loc
        print  "size of data ",len(self.data[0]),len(self.data[1]),len(self.data[2])
        
def setParams(ip):
    if len(sys.argv) !=2:
        print "not enugh arguments"
        sys.exit()
    else:
        ip.fname = sys.argv[1]
            

#function to set the grid
def set_grid(ip,grid,x,y,z,val):
    if ((x > grid.xsize + 1)or (y > grid.xsize + 1))or\
    (z > grid.xsize + 1):
        print "error ", x, " ", y, " ", z
    else:
        grid.data[x][y][z] = float(val)
#Function to read the bytes 
def readBytes(ip):
    with open(ip.fname, "rb") as f:
        byte = f.read(1)
        while byte != "":
            ip.dataBytes.append(byte)
            byte = f.read(1)   
def convert(ip,returnType,size):
    ip.currLoc = ip.currLoc + size
    return struct.unpack(returnType,''.join(ip.dataBytes[ip.currLoc-size:ip.currLoc]))[0]


def updateBaseLocation (ip,grid,indx):
    for d in range (3):
        grid.cuur_bas_loc[d] = grid.cuur_bas_loc[d] + grid.offset[indx][d]*grid.vertPerUnitL

def revertBaseLocation (grid, tempBaseLoc):
    grid.cuur_bas_loc = [tempBaseLoc[x] for x in range (3)]
                    
def readDCF(ip,grid):
    readBytes(ip)
    grid.setSize(convert(ip,"i",4),convert(ip,"i",4),convert(ip,"i",4))
    grid.vertPerUnitL=grid.xsize
         
    print len(ip.dataBytes),
    print 'in dcf read',
    print "filename ", ip.fname
    print "grid vert Per unit ", grid.vertPerUnitL
    
#main program 
def findType(ip):
    return convert(ip,"i",4)


def updateScalarOfCoord(ip,grid,indx,val):
    x=grid.cuur_bas_loc[0]+ int(grid.offset[indx][0])
    y=grid.cuur_bas_loc[1]+ int(grid.offset[indx][1])
    z=grid.cuur_bas_loc[2]+ int(grid.offset[indx][2])
    set_grid(ip,grid,x,y,z,val)
            
def leafNode(ip,grid):
    for i in range (8):
        val=convert(ip,"h",2)
        updateScalarOfCoord(ip,grid,i,val)
        
    for j in range (12):
        
        num_edge_intersection = convert(ip,"i",4)
        if num_edge_intersection > 1:
            print "num of edge intersection > 1"
            sys.exit()
        else:
            for k in range (num_edge_intersection):
                tempEdgeInfo=[]
                edgeOffset = convert(ip,"f",4)
                edgeEnd1Index = grid.edgeOffset[j][0]
                edgeEnd2Index = grid.edgeOffset[j][1]
                edgeEnd1Coord = [grid.cuur_bas_loc[x]+grid.offset[edgeEnd1Index][x]\
                                 for x in range (3)]
                edgeEnd2Coord = [grid.cuur_bas_loc[x]+grid.offset[edgeEnd2Index][x]\
                                for x in range (3)]
                edgeIntersect = [edgeEnd1Coord[x]+\
                                 ( grid.offset[edgeEnd2Index][x]-grid.offset[edgeEnd1Index][x])*edgeOffset for x in range(3)]
                ''' DEBUG
                edgeIntersect = [edgeEnd1Coord[x]+\
                                 ( edgeEnd2Coord[x]-edgeEnd1Coord[x])*edgeOffset for x in range(3)]
                '''
                '''
                tempEdgeInfo.append([edgeEnd1Coord[x]+\
                                     ( edgeEnd2Coord[x]-edgeEnd1Coord[x])*edgeOffset for x in range(3)])
                '''
                tempEdgeInfo.append(edgeIntersect)
                gradient=[]
                for d in range(3):
                    gradient.append(convert(ip,"f",4)),
                tempEdgeInfo.append(gradient)
                grid.edgeIntersections.append([tempEdgeInfo])
            
# fill the nodes which are either completely inside or outside 
def fillNode(ip,grid, isinside):
    for i in range(grid.vertPerUnitL+1):
        for j in range (grid.vertPerUnitL+1):
            for k in range(grid.vertPerUnitL+1):
                x = int(grid.cuur_bas_loc[0])+i
                y = int(grid.cuur_bas_loc[1])+j
                z = int(grid.cuur_bas_loc[2])+k
                set_grid(ip,grid,x,y,z,isinside)
            
def readNode(ip,grid):
    nodetype = findType(ip)  
    if nodetype==0:
        grid.vertPerUnitL=grid.vertPerUnitL/2
        #save the current baseLocation 
        tempBaseLoc = list (grid.cuur_bas_loc)
        tempHeight  = grid.vertPerUnitL
        for i in range (8):
            revertBaseLocation (grid,tempBaseLoc)
            grid.vertPerUnitL = tempHeight
            updateBaseLocation (ip,grid,i)
            readNode(ip,grid)
    elif nodetype==1:
        #print "empty ",
        isinside = convert (ip,"h",2)
        fillNode(ip,grid, isinside)
    elif nodetype==2:
        #print "leaf",
        grid.num_leaf = grid.num_leaf+1
        leafNode(ip,grid)
    else:
        print "error uknow nodeType ", nodeType
        sys.exit()
 
def outNrrd(ip,grid):
    outNrrd="out.nrrd"
    f = open(outNrrd, 'w ')
    print >>f, "NRRD0001"
    print >>f, "dimension: 3 \ntype: int"
    print >>f, "sizes:", grid.xsize+1,grid.ysize+1,grid.zsize+1
    print >>f, "spacings: 1 1 1"
    print >>f, "encoding: text"
    print >>f, "\n"
    for i in range (grid.xsize+1):
        for j in range (grid.ysize+1):
            for k in range (grid.zsize+1):
                print >>f,grid.data[k][j][i],

def outTxt(ip,grid):
    outNrrd="out.txt"
    f = open(outNrrd, 'w ')
    print >>f, "NRRD0001 text"
    print >>f, "dimension: 3 \ntype: int"
    print >>f, "sizes:", grid.xsize+1,grid.ysize+1,grid.zsize+1
    print >>f, "spacings: 1 1 1"
    print >>f, "encoding: ascii"
    print >>f, "\n"
    for i in range (grid.xsize+1):
        for j in range (grid.ysize+1):
            for k in range (grid.zsize+1):
                print >>f,"[",i,j,k,"]",grid.data[k][j][i],
            print >>f,""
        print >>f,""    
        
        
def outOFF(grid):
    f=open("out.off","w")
    print "len",len(grid.edgeIntersections)
    edgeinterLen = len(grid.edgeIntersections)
    print >>f,"NOFF"
    print >>f,edgeinterLen, "0 0 "
    for x in grid.edgeIntersections:
        
        print >>f,x[0][0][0],x[0][0][1],x[0][0][2]," ",\
        x[0][1][0],x[0][1][1],x[0][1][2]
        
        #print >>f,x[0][0][0],x[0][0][1],x[0][0][2]
def main():
    ip = Params()
    setParams(ip);
    grid = gridType()
    readDCF(ip,grid)
    readNode(ip,grid)
    outNrrd(ip,grid)
    outTxt(ip,grid)
    outOFF(grid)
    grid.debugPrint()
    
    
# call the main function
if __name__ == "__main__":
    main()
    
